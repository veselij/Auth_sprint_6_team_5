## Компоненты

##### Redis - хранение jwt 

1. Таблица всех актуальных токенов для рефреша (refresh_token) токенов доступа (access_token). Храним в формате {key: refresh_token_id, value: user_uuid} time to live = дата валидности токена
2. Таблица дат, старше которой должен быть access_token юзера, чтобы считать валидным. Храним в формате {key: user_uuid, value: datetime, access_token_id (if None -> any tokens should be older)},
time to live = время жизни refresh_token. данные попадают в эту таблицу например когда юзер сделает логаут (тогда access_token_id = из запроса), логаут со всех устройств (тогда None)
 Когда придет запрос от клиента, проверяем есть ли его ID в Таблице 2, если есть то смотрим, чему равен access_token_id, если None, то сравниваем время выпуска токена с datatime из Таблицы 2, если
 меньше, то отказываем в авторизации. Если, не None, то сначала проверям равны ли access id и потом сверяем время.
 Аналогично для refresh токенов, только отказываем в рефреше.

##### Postgress - основная БД

1.  Таблица user (id, login, password, is_superuser)
2.  Таблица role (id, role_name, role_description)
3.  Таблица user_role (id, user_id, role_id)
4.  Таблица access_history (id, user_id, user_agent, login_date, login_status)

##### Flask server приложения реализующего 2 группы API

1. Регистрации, аутентификации, авторизации, и выпуска токенов
	- регистрация пользователя;
	- вход пользователя в аккаунт (обмен логина и пароля на пару токенов: JWT-access токен и refresh токен
	- обновление access-токена;
	- выход пользователя из аккаунта;
	- изменение логина или пароля 
	- получение пользователем своей истории входов в аккаун
	- получение пользователем своих данных (first_name, last_name)
	
2.  Создания и управления ролями
	- CRUD для управления ролями:
		- создание роли
		- удаление роли,
		- изменение роли,
		- просмотр всех ролей.
	- назначить пользователю роль; после этого рефрешить токены юзеру и добавлять туда группу
	- отобрать у пользователя роль; после этого рефрешить токены юзеру и добавлять туда группу
	- метод для проверки наличия прав у пользователя (вытаскивать из токена group_id)
	
##### Nginx
1. Проксирование запросов

## Изменения в предыдущих сервисах
Так как будет использоваться Role based система для определения доступных фильмов необходимо:
	- в фильмы в postgress добавить поле указание какой роли оно доступно. Many2Many relations. Отдельная таблица подписок нужна. Как-то ее синхрить отсюда
	- в ETL добавить это поле (массив индексов - подписок в которых доступен фильм)
	- в ES в индекс добавить это поле
  

## Библиотеки

- Flask
- SqlAlchemy
- redis-py
- flask-marshmallow
- flasgger
- flask-security
- flask-jwt-extended


## Проработать
- Продумайте, как реализовать работу с анонимными пользователями: они могут выполнять только те действия, для которых не нужны особые права.
- Добавьте консольную команду для создания суперпользователя, которому всегда разрешено делать все действия в системе.
- Чтобы упростить себе жизнь с настройкой суперпользователя, продумайте, как сделать так, чтобы при авторизации ему всегда отдавался успех при всех запросах. (через декоратор для ендпоинтов)

## Ограничения
1. Создавать, редактировать и удалять роли может только суперпользователь
2. Роли нужны только для ограничения доступа к фильмам. Т.е. реализуют механизм подписок
3. Кто будет добавлять роли юзерам - сам юзер (после валидации оплаты) или супер пользователь - будет решено позже


## Формат токена
```
access token payload
{
	"user_id": "",
	"group_id": [1,2,3],
	"created_at": ""
	"expire_at": ""
}

refresh token payload
{
	"user_id": "",
	"access_token_id":"",
	"created_at": ""
	"expire_at": ""
}
```
