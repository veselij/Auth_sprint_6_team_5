# Сервис авторизации с использованием JWT токенов
Данный сервис выполняет следующие функции:
1. Регистарация пользователей:
	- по логину и паролю
	- через сторонних провайдеров - google и yandex
1. Авторизация пользователей по логину и паролю с последующей генерацией токенов доступа
	- в сервисе используется 2 типа токенов - access_token (с ограниченным временем жизни) - для авторизации и refresh_token (с более длительным сроком жизни) - для получения новой пары токенов
	- для обновления токенов предоставлен отдельный end point
	- так же возможно подключение проверки TOTP с помощью Google Authenticator. Это делается через выделенные end points. в Случае подключения TOTP его сначала надо будет синхронизировать, далее после проверки логина пароля для получения токена необходимо запросить jwt токены с предоставдением TOTP кода
2. Обновления данных пользователя
3. Упрaвления ролями пользователей:
	- создание роли
	- удаление роли,
	- изменение роли,
	- просмотр всех ролей.
4.  Управления ролями пользователей:
	- назначение пользователю роли
	- удаление у пользователя роли
	- проверки наличия прав (ролей) у пользователя.

Детальная информация по API расписана в документации (Docs), так же доступна в свагере:
http://127.0.0.1:8000/apidocs/#/

## Запуск сервиса
Запуск сервиса
```
git clone 
cd flask-auth-api
docker-compose build
docker-compose up
```
Проверка тестов
```
cd tests/functional
docker-compose build
docker-compose up
```
Создание супер пользователя из переменных окружения
```
python -m flask superuser create --no-interactive
```
Создание супер пользователя интерактивно
```
python -m flask superuser create
```

## Компоненты

##### Redis

1. Таблица всех актуальных токенов для рефреша (refresh_token). Храним в формате {key: refresh_token_id, value: user_uuid}.
2. Таблица дат, старше которой должен быть access_token юзера, чтобы считать валидным. Храним в формате {key: user_uuid, value: {access_token_id: datetime} (if access_token_id="all" -> все tokens должны быть старше даты)},
Данные попадают в эту таблицу например когда юзер сделает логаут (тогда access_token_id = из запроса), логаут со всех устройств (тогда all)
Когда придет запрос от клиента, проверяем есть ли его ID в Таблице 2, если есть то смотрим, чему равен access_token_id, если all, то сравниваем время выпуска токена с datatime из Таблицы 2, если
меньше, то отказываем в авторизации. Если, не all, то сначала проверям равны ли access id и потом сверяем время.
Аналогично для refresh токенов, только отказываем в рефреше.

##### Postgress - основная БД

1.  Таблица user (id, login, password, is_superuser)
2.  Таблица role (id, role_name, role_description)
3.  Таблица user_role (id, user_id, role_id)
4.  Таблица access_history (id, user_id, user_agent, login_date, login_status)

##### Flask server приложения реализующего 2 группы API

1. Регистрации, аутентификации, авторизации, и выпуска токенов
	- регистрация пользователя;
	- вход пользователя в аккаунт (обмен логина и пароля на пару токенов: JWT-access токен и refresh токен
	- обновление access-токена;
	- выход пользователя из аккаунта;
	- изменение логина или пароля 
	- получение пользователем своей истории входов в аккаун
	- получение пользователем своих данных (first_name, last_name)
	
2.  Создания и управления ролями
	- CRUD для управления ролями:
		- создание роли
		- удаление роли,
		- изменение роли,
		- просмотр всех ролей.
	- назначить пользователю роль; после этого рефрешить токены юзеру и добавлять туда группу
	- отобрать у пользователя роль; после этого рефрешить токены юзеру и добавлять туда группу
	- метод для проверки наличия прав у пользователя (вытаскивать из токена group_id)
	
##### Nginx
1. Проксирование запросов

##### Jaeger
1. Опционально можно настроить тресинг запросов сервеиса в Jaeger через выставление флага JAGER_STATUS=TRUE в переменных окружения

## Основные библиотеки

- Flask
- SqlAlchemy
- redis-py
- marshmallow
- flasgger
- flask-jwt-extended
- alembic
- Redis
- opentelemetry

## Ограничения
1. Создавать, редактировать и удалять роли может только суперпользователь
2. Роли нужны только для ограничения доступа к фильмам. Т.е. реализуют механизм подписок
3. Добавлять роли юзерам может только супер пользователь